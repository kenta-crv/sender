require "net/http"
require "json"
require "openssl"

class GptArticleGenerator
  # ä¿®æ­£1: 1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚ãŸã‚Šã®ç›®æ¨™æ–‡å­—æ•°ã‚’300æ–‡å­—ã«èª¿æ•´ã€‚
  TARGET_CHARS_PER_SECTION = 300 
  # ä¿®æ­£2: 1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚ãŸã‚Šã®å³æ ¼ãªæ–‡å­—æ•°ä¸Šé™ã€‚
  MAX_CHARS_PER_SECTION = 500
  MODEL_NAME = "gpt-4o-mini" # ä½¿ç”¨ãƒ¢ãƒ‡ãƒ«
  
  # ç’°å¢ƒå¤‰æ•°ã‹ã‚‰OpenAI API Keyã‚’å–å¾—
  GPT_API_KEY = ENV["OPENAI_API_KEY"] 
  GPT_API_URL = "https://api.openai.com/v1/chat/completions"

  def self.generate_body(column)
    # ğŸš¨ STEP 0: APIã‚­ãƒ¼ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ ğŸš¨
    unless GPT_API_KEY.present?
      Rails.logger.error("ã€è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼ã€‘OPENAI_API_KEY ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç’°å¢ƒå¤‰æ•°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
      return nil
    end

    # è¨˜äº‹æœ¬æ–‡ã®åˆæœŸå€¤ï¼ˆã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«DBã«æ›¸ãè¾¼ã¾ã‚Œã‚‹ã®ã‚’é˜²ããŸã‚ã€nilã‚’è¿”ã™å‰æã¨ã™ã‚‹ï¼‰
    original_body = column.body 

    # ==========================================
    # STEP 1: è¨˜äº‹å…¨ä½“ã®æ§‹æˆï¼ˆH2ã¨H3ã®ãƒã‚¹ãƒˆæ§‹é€ ï¼‰ã‚’JSONã§ä½œæˆã™ã‚‹
    # ==========================================
    Rails.logger.warn("â˜…â˜†â˜… GptArticleGenerator.generate_body ãŒå®Ÿè¡Œã•ã‚Œã¾ã—ãŸï¼ â˜…â˜†â˜…") # å®Ÿè¡Œãƒã‚§ãƒƒã‚¯
    Rails.logger.info("--- STEP 1: è¨˜äº‹æ§‹æˆã®ç”Ÿæˆã‚’é–‹å§‹ (ãƒã‚¹ãƒˆJSONè¦æ±‚) ---")
    
    # ä¿®æ­£ã•ã‚ŒãŸæ§‹æˆç”Ÿæˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å‘¼ã³å‡ºã™
    structure_prompt = self.structure_generation_prompt(column)
    
    # JSONãƒ¢ãƒ¼ãƒ‰ã§APIã‚’å‘¼ã³å‡ºã™
    structure_response = self.call_gpt_api(structure_prompt, response_format: { type: "json_object" })
    
    structure = [] # H2ã¨H3ã®ãƒã‚¹ãƒˆã•ã‚ŒãŸæ§‹é€ ã‚’æ ¼ç´
    
    if structure_response.nil?
      Rails.logger.error("æ§‹æˆæ¡ˆã®APIå¿œç­”ãŒnilã§ã—ãŸã€‚")
      return original_body
    end

    begin
      json_str = structure_response.dig("choices", 0, "message", "content")
      Rails.logger.info("JSON APIå¿œç­” (ç”Ÿ): #{json_str.to_s.truncate(200)}")
      
      # å–å¾—ã—ãŸJSONæ–‡å­—åˆ—ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã€ãƒã‚¹ãƒˆã•ã‚ŒãŸ'structure'é…åˆ—ã‚’å–å¾—
      structure_data = JSON.parse(json_str)
      structure = structure_data["structure"] || []
      
      Rails.logger.info("è¦‹å‡ºã—æŠ½å‡ºæˆåŠŸã€‚H2è¦‹å‡ºã—æ•°: #{structure.length}å€‹")

      # H2è¦‹å‡ºã—æ•°ãŒæ¥µç«¯ã«å°‘ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦æ‰±ã†
      if structure.length < 3
        Rails.logger.error("H2è¦‹å‡ºã—ã®ç”Ÿæˆã«å¤±æ•—ã€ã¾ãŸã¯æ•°ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆ#{structure.length}å€‹ï¼‰ã€‚å‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã™ã€‚")
        return original_body
      end

    rescue JSON::ParserError => e
      Rails.logger.error("é‡å¤§ã‚¨ãƒ©ãƒ¼: JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: #{e.message}. APIãŒä¸æ­£ãªJSONã‚’è¿”ã—ã¾ã—ãŸã€‚")
      Rails.logger.error("ä¸æ­£ãªJSONæ–‡å­—åˆ—: #{json_str.to_s.truncate(500)}")
      return original_body
    rescue => e
      Rails.logger.error("é‡å¤§ã‚¨ãƒ©ãƒ¼: æ§‹æˆæ¡ˆå‡¦ç†ä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: #{e.message}")
      return original_body
    end

    # ==========================================
    # STEP 2: å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æœ¬æ–‡ã‚’ãƒ«ãƒ¼ãƒ—ã§ç”Ÿæˆãƒ»çµåˆã™ã‚‹ 
    # ==========================================
    Rails.logger.info("--- STEP 2: H2/H3ãƒã‚¹ãƒˆæœ¬æ–‡ç”Ÿæˆãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ ---")
    full_article = ""
    
    # 1. å°å…¥æ–‡ï¼ˆãƒªãƒ¼ãƒ‰ï¼‰ã®ç”Ÿæˆ
    intro_prompt = self.introduction_prompt(column)
    # å°å…¥ã®å¤±æ•—æ™‚ã¯H2ã®å¤±æ•—ã¨åŒã˜ã‚ˆã†ã«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’æ®‹ã™
    full_article += self.generate_section_content("å°å…¥", intro_prompt, column, heading_level: "") + "\n\n" # å°å…¥æ–‡ã«è¦‹å‡ºã—ã¯ä¸è¦ãªãŸã‚ã€levelã‚’ç©ºã«

    # 2. H2ã¨H3ã®è¦‹å‡ºã—ã”ã¨ã®æœ¬æ–‡ç”Ÿæˆ
    total_h2 = structure.length
    structure.each_with_index do |h2_section, index|
      h2_title = h2_section["h2_title"]
      h3_sub_sections = h2_section["h3_sub_sections"] || []

      # H2è¦‹å‡ºã—è‡ªä½“ã‚’Markdownã§è¿½åŠ ï¼ˆ##ï¼‰
      full_article += "## #{h2_title}\n\n"
      Rails.logger.info("H2ã‚»ã‚¯ã‚·ãƒ§ãƒ³è¦‹å‡ºã—ã‚’è¿½åŠ  (#{index + 1}/#{total_h2}): #{h2_title}")
      
      # H3ã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æœ¬æ–‡ç”Ÿæˆ (è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«: ###)
      if h3_sub_sections.any?
        h3_sub_sections.each_with_index do |h3_title, sub_index|
          Rails.logger.info("  â†³ H3ã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆä¸­ (#{sub_index + 1}): #{h3_title}")
          h3_prompt = self.section_content_prompt(column, h3_title, "H3", parent_h2: h2_title) # level: H3, parent_h2: H2ã‚¿ã‚¤ãƒˆãƒ«
          full_article += self.generate_section_content(h3_title, h3_prompt, column, heading_level: "###") + "\n\n"
          sleep(0.5)
        end
      else
        # H3ãŒãªã„å ´åˆã®ã¿ã€H2ç›´ä¸‹ã®æœ¬æ–‡ã‚’ç”Ÿæˆã™ã‚‹
        Rails.logger.warn("  â†³ H3ã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒãªã„ãŸã‚ã€H2ç›´ä¸‹ã®æœ¬æ–‡ã‚’ç”Ÿæˆã—ã¾ã™ã€‚")
        h2_prompt = self.section_content_prompt(column, h2_title, "H2")
        # heading_levelã‚’ç©ºã«ã—ã¦ã€è¦‹å‡ºã—è‡ªä½“ã¯å«ã‚ãšæœ¬æ–‡ã®ã¿ã‚’H2è¦‹å‡ºã—ã®ç›´ä¸‹ã«è¿½åŠ 
        full_article += self.generate_section_content(h2_title, h2_prompt, column, heading_level: "") + "\n\n"
      end

      # APIãƒ¬ãƒ¼ãƒˆåˆ¶é™å›é¿ã¨å®‰å®šæ€§ã®ãŸã‚ã«ã‚¹ãƒªãƒ¼ãƒ—ã‚’å…¥ã‚Œã‚‹
      sleep(0.5) 
    end

    # 3. ã¾ã¨ã‚ãƒ»CTAã®ç”Ÿæˆ
    cta_prompt = self.conclusion_and_cta_prompt(column)
    # ã¾ã¨ã‚ã¯ã€Œ## ã¾ã¨ã‚ã€ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå†…ã§ç”Ÿæˆã•ã›ã‚‹ãŸã‚ã€heading_levelã¯ç©º
    full_article += self.generate_section_content("ã¾ã¨ã‚", cta_prompt, column, heading_level: "")
    
    Rails.logger.info("--- å…¨ã¦ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸã€‚åˆè¨ˆæ–‡å­—æ•°: #{full_article.length} ---")
    return full_article
  end
  
  private

  # ==========================================
  # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤
  # ==========================================
  
  def self.ok_delivery_strengths
    # ã“ã®æƒ…å ±ã¯ã€æœ€å¾Œã«å‘¼ã³å‡ºã™CTAãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã®ã¿ä½¿ç”¨ã—ã¾ã™ã€‚
    <<~STRENGTHS
      # OKé…é€ã®ã‚»ãƒ¼ãƒ«ã‚¹ãƒã‚¤ãƒ³ãƒˆ
      - å¼·ã¿1ï¼šæ—¥æœ¬å…¨å›½ã©ã“ã§ã‚‚è»½è²¨ç‰©é…é€å¯èƒ½ãªäººæã‚’é›†ã‚ã‚‰ã‚Œã‚‹
      - å¼·ã¿2ï¼šæ—©æœã‹ã‚‰æ·±å¤œãƒ»ä¼æ¥­é…é€ã€œå€‹äººé…é€ã¾ã§å¹…åºƒãå¯¾å¿œ
      - å¼·ã¿3ï¼šãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã®å¤§é‡å‹Ÿé›†ã‚„åœ°æ–¹ã®ç‰©æµç’°å¢ƒæ§‹ç¯‰ã¾ã§ã‚µãƒãƒ¼ãƒˆ
    STRENGTHS
  end
  
  def self.structure_generation_prompt(column)
    # STEP 1ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    <<~PROMPT
      ã‚ãªãŸã¯ãƒ—ãƒ­ã®ãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒã§ãƒ–ãƒ­ã‚°è¨˜äº‹ã®ã€Œè©³ç´°ãªæ§‹æˆæ¡ˆã€ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
      
      # è¨˜äº‹æƒ…å ±
      - ã‚¿ã‚¤ãƒˆãƒ«: #{column.title}
      - æ¦‚è¦: #{column.description}
      - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: #{column.keyword}
      - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: è»½è²¨ç‰©é…é€ã‚’ä¾é ¼ã—ãŸã„ä¼æ¥­ã®æ‹…å½“è€…
      
      # æŒ‡ç¤º (æ§‹æˆã®æ•°ã‚’å³æ ¼ã«åˆ¶é™ã¨è«–æ—¨ã®ä¸€è²«æ€§ã‚’å¼·èª¿)
      1. **ä¸€ã¤ã®ç‰©èªã¨ã—ã¦èª­è€…ã®ç†è§£ãŒæ·±ã¾ã‚‹ã€è«–ç†çš„ã§ä¸€è²«æ€§ã®ã‚ã‚‹æ§‹æˆ**ã«ã—ã¦ãã ã•ã„ã€‚
      2. H2è¦‹å‡ºã—ã¯**æœ€å¤§4ã¤**ã¾ã§ã¨ã—ã¦ãã ã•ã„ã€‚
      3. å„H2è¦‹å‡ºã—é…ä¸‹ã®H3è¦‹å‡ºã—ã¯**æœ€å¤§3ã¤**ã¾ã§ã¨ã—ã¦ãã ã•ã„ã€‚
      4. å°å…¥ï¼ˆãƒªãƒ¼ãƒ‰ï¼‰ã¨ã¾ã¨ã‚ï¼ˆCTAï¼‰ã¯åˆ¥é€”ç”Ÿæˆã™ã‚‹ãŸã‚ã€ã“ã®ãƒªã‚¹ãƒˆã«ã¯å«ã‚ãªã„ã§ãã ã•ã„ã€‚
      5. ã“ã®æ§‹æˆã¨ã€1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚ãŸã‚Š#{TARGET_CHARS_PER_SECTION}ã€œ#{MAX_CHARS_PER_SECTION}æ–‡å­—ã‚’ç›®å®‰ã¨ã—ã¦ã€åˆè¨ˆ4,000æ–‡å­—ã€œ7,000æ–‡å­—ç¨‹åº¦ã®è¨˜äº‹ã«ãªã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
      6. å‡ºåŠ›ã¯å¿…ãšä»¥ä¸‹ã®**JSONå½¢å¼ã®ã¿**ã§è¡Œã£ã¦ãã ã•ã„ã€‚ä½™è¨ˆãªæŒ¨æ‹¶ã‚„ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’ä¸€åˆ‡å«ã‚ãªã„ã§ãã ã•ã„ã€‚

      # å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ(JSON)
      {
        "structure": [
          {
            "h2_title": "H2è¦‹å‡ºã—ã®ã‚¿ã‚¤ãƒˆãƒ«",
            "h3_sub_sections": [
              "H3å°è¦‹å‡ºã—1ã®ã‚¿ã‚¤ãƒˆãƒ«",
              "H3å°è¦‹å‡ºã—2ã®ã‚¿ã‚¤ãƒˆãƒ«"
            ]
          },
          ...
        ]
      }
    PROMPT
  end

  def self.introduction_prompt(column)
    # å°å…¥æ–‡ç”Ÿæˆç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    <<~PROMPT
      ã‚¿ã‚¤ãƒˆãƒ«ã€Œ#{column.title}ã€ã®è¨˜äº‹ã®ã€Œå°å…¥æ–‡ï¼ˆãƒªãƒ¼ãƒ‰ï¼‰ã€ã‚’åŸ·ç­†ã—ã¦ãã ã•ã„ã€‚
      
      # åŸ·ç­†æŒ‡ç¤º (æ–‡å­—æ•°ã‚’å³æ ¼ã«åˆ¶é™)
      - **æ–‡å­—æ•°:** **#{TARGET_CHARS_PER_SECTION}æ–‡å­—ç¨‹åº¦**ã‚’ç›®æ¨™ã¨ã—ã€ã„ã‹ãªã‚‹å ´åˆã‚‚**#{MAX_CHARS_PER_SECTION}æ–‡å­—ã‚’è¶…éã—ãªã„ã§ãã ã•ã„**ã€‚è¶…éã—ãŸå ´åˆã€è¨˜äº‹å…¨ä½“ã®æ§‹æˆãŒç ´ç¶»ã—ã¾ã™ã€‚
      - ãƒˆãƒ¼ãƒ³ã¯ä¿¡é ¼æ„Ÿã®ã‚ã‚‹ãƒ“ã‚¸ãƒã‚¹ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã§ã€èª­è€…ã®å…±æ„Ÿã‚’å‘¼ã³ã€è¨˜äº‹ã‚’èª­ã¿é€²ã‚ãŸããªã‚‹å†…å®¹ã«ã—ã¦ãã ã•ã„ã€‚
      - æœ¬æ–‡ã¯**æ®µè½ï¼ˆç©ºè¡Œï¼‰**ã€**å¤ªå­—ï¼ˆ**å¤ªå­—**ï¼‰**ã€**ç®‡æ¡æ›¸ã**ã‚’ç©æ¥µçš„ã«ä½¿ã„ã€å¯èª­æ€§ã‚’æœ€å¤§åŒ–ã—ã¦ãã ã•ã„ã€‚
      - **è¦‹å‡ºã—ã¯ä¸€åˆ‡å«ã‚ãªã„ã§ãã ã•ã„ã€‚**
    PROMPT
  end

  # H2ã¨H3ä¸¡æ–¹ã§ä½¿ã†ã‚»ã‚¯ã‚·ãƒ§ãƒ³æœ¬æ–‡ç”Ÿæˆç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
  def self.section_content_prompt(column, headline, level, parent_h2: nil)
    # ã‚»ã‚¯ã‚·ãƒ§ãƒ³æœ¬æ–‡ç”Ÿæˆç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    parent_context = parent_h2 ? "\n- è¦ªã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆH2ï¼‰: #{parent_h2}" : ""
    heading_marker = level == "H2" ? "##" : "###"

    # H2ç›´ä¸‹ã®æœ¬æ–‡ç”Ÿæˆã¯H3ãŒãªã„å ´åˆã®ã¿ã®ãŸã‚ã€H2ã®å ´åˆã¯è¦‹å‡ºã—å«ã‚ãšæœ¬æ–‡ã®ã¿ã‚’ç”Ÿæˆã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ã™ã‚‹
    if level == "H2"
      heading_instruction = "æœ¬æ–‡ã®ã¿ã‚’åŸ·ç­†ã—ã€è¦‹å‡ºã—ï¼ˆ#{heading_marker} #{headline}ï¼‰ã¯å«ã‚ãªã„ã§ãã ã•ã„ã€‚è¦‹å‡ºã—ã¯åˆ¥ã§è¿½åŠ ã—ã¾ã™ã€‚"
    elsif level == "H3"
      # H3ã®å ´åˆã¯è¦‹å‡ºã—ã‚’æ–‡é ­ã«å«ã‚ã‚‹ï¼ˆMarkdownå½¢å¼ï¼‰
      heading_instruction = "**è¦‹å‡ºã—è‡ªä½“ï¼ˆ#{heading_marker} #{headline}ï¼‰ã‚’æ–‡é ­ã«å«ã‚ã¦Markdownå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚**"
    else
      heading_instruction = ""
    end

    <<~PROMPT
      ãƒ–ãƒ­ã‚°è¨˜äº‹ã®ä»¥ä¸‹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æœ¬æ–‡ã‚’åŸ·ç­†ã—ã¦ãã ã•ã„ã€‚
      
      # è¨˜äº‹å…¨ä½“ã®æ–‡è„ˆ
      - ã‚¿ã‚¤ãƒˆãƒ«: #{column.title}
      - ãƒ¡ã‚¤ãƒ³ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: #{column.keyword}
      - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: è»½è²¨ç‰©é…é€ã‚’ä¾é ¼ã—ãŸã„ä¼æ¥­ã®æ‹…å½“è€…
      
      # ç¾åœ¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³æƒ…å ±
      - è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«: #{level}#{parent_context}
      - è¦‹å‡ºã—ã‚¿ã‚¤ãƒˆãƒ«: #{headline}
      
      # åŸ·ç­†æŒ‡ç¤º (æ–‡å­—æ•°ã¨å†…å®¹ã®å³æ ¼ãªåˆ¶é™)
      - ã“ã®è¦‹å‡ºã—é…ä¸‹ã®æœ¬æ–‡ã®ã¿ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚
      - **æ–‡å­—æ•°:** **#{TARGET_CHARS_PER_SECTION}æ–‡å­—ç¨‹åº¦**ã‚’ç›®æ¨™ã¨ã—ã€ã„ã‹ãªã‚‹å ´åˆã‚‚**#{MAX_CHARS_PER_SECTION}æ–‡å­—ã‚’è¶…éã—ãªã„ã§ãã ã•ã„**ã€‚
      - **å†…å®¹ã®å³æ ¼ãªåˆ¶é™:** **OKé…é€ã®å®£ä¼ã‚„ã€ãã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã¾ã¨ã‚ã¯ä¸€åˆ‡å«ã‚ãªã„ã§ãã ã•ã„**ã€‚ç´”ç²‹ã«æƒ…å ±æä¾›ã¨è«–ç‚¹ã®æ·±æ˜ã‚Šã«é›†ä¸­ã—ã€æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¸ã¨è«–ç†çš„ã«ç¹‹ã’ã¦ãã ã•ã„ã€‚
      - **å¯èª­æ€§ã®ç¢ºä¿:** æœ¬æ–‡ã¯å¿…ãš**æ®µè½ï¼ˆç©ºè¡Œï¼‰**ã€**å¤ªå­—ï¼ˆ**å¤ªå­—**ï¼‰**ã€**ç®‡æ¡æ›¸ã**ã‚’ç©æ¥µçš„ã«ä½¿ã„ã€æ–‡ç« ã®å›ºã¾ã‚Šã‚’é˜²ã„ã§ãã ã•ã„ã€‚
      - **H4ã®åˆ©ç”¨ï¼ˆé‡è¦ï¼‰:** ã‚‚ã—æ–‡ç« å†…ã§ç‰¹å®šã®ãƒã‚¤ãƒ³ãƒˆã‚’ã•ã‚‰ã«ç´°åˆ†åŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€**`####` (H4è¦‹å‡ºã—)**ã‚’é©åˆ‡ã«åˆ©ç”¨ã—ã¦æ§‹é€ åŒ–ã‚’æ·±ã‚ã¦ãã ã•ã„ã€‚
      - å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿ã€äº‹ä¾‹ã€ãƒ¡ãƒªãƒƒãƒˆãªã©ã‚’è©³ç´°ã«è¨˜è¿°ã—ã€å°‚é–€æ€§ã‚’æŒãŸã›ã¦ãã ã•ã„ã€‚
      - èªã‚Šå£: ä¿¡é ¼æ„Ÿã®ã‚ã‚‹ãƒ“ã‚¸ãƒã‚¹ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ï¼ˆã§ã™ãƒ»ã¾ã™èª¿ï¼‰ã€‚
      - #{heading_instruction}
    PROMPT
  end

  def self.conclusion_and_cta_prompt(column)
    # ã¾ã¨ã‚ãƒ»CTAç”Ÿæˆç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    <<~PROMPT
      è¨˜äº‹ã®ã€Œã¾ã¨ã‚ã€ã¨ã€ŒCTAï¼ˆè¡Œå‹•å–šèµ·ï¼‰ã€ã‚’åŸ·ç­†ã—ã¦ãã ã•ã„ã€‚
      
      # æŒ‡ç¤º (æ–‡å­—æ•°ã‚’å³æ ¼ã«åˆ¶é™)
      - **æ–‡å­—æ•°:** **#{TARGET_CHARS_PER_SECTION}æ–‡å­—ç¨‹åº¦**ã‚’ç›®æ¨™ã¨ã—ã€ã„ã‹ãªã‚‹å ´åˆã‚‚**#{MAX_CHARS_PER_SECTION}æ–‡å­—ã‚’è¶…éã—ãªã„ã§ãã ã•ã„**ã€‚è¶…éã—ãŸå ´åˆã€è¨˜äº‹å…¨ä½“ã®æ§‹æˆãŒç ´ç¶»ã—ã¾ã™ã€‚
      - è¨˜äº‹å…¨ä½“ã®è¦ç´„ã‚’ç°¡æ½”ã«è¿°ã¹ã‚‹ã€‚
      - æœ€å¾Œã«ã€è²´ç¤¾ã®ã‚µãƒ¼ãƒ“ã‚¹ã€ŒOKé…é€ã€ã¸ã®å…·ä½“çš„ãªå•ã„åˆã‚ã›ï¼ˆã‚µãƒ¼ãƒ“ã‚¹è©³ç´°ã‚„è¦‹ç©ã‚‚ã‚Šä¾é ¼ï¼‰ã‚’ä¿ƒã™**å¼·åŠ›ãªè¡Œå‹•å–šèµ·ï¼ˆCTAï¼‰**ã‚’å«ã‚ã¦ãã ã•ã„ã€‚
      - OKé…é€ã®å¼·ã¿: #{self.ok_delivery_strengths}
      - æœ¬æ–‡ã¯**æ®µè½ï¼ˆç©ºè¡Œï¼‰**ã€**å¤ªå­—ï¼ˆ**å¤ªå­—**ï¼‰**ã€**ç®‡æ¡æ›¸ã**ã‚’ç©æ¥µçš„ã«ä½¿ã„ã€å¯èª­æ€§ã‚’æœ€å¤§åŒ–ã—ã¦ãã ã•ã„ã€‚
      - **è¦‹å‡ºã—ã€Œ## ã¾ã¨ã‚ã€ã‹ã‚‰å§‹ã‚ã¦ãã ã•ã„ã€‚**
    PROMPT
  end

  # ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰: å€‹åˆ¥ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆã‚’å®Ÿè¡Œ
  def self.generate_section_content(section_name, prompt, column, heading_level: "##")
    response = self.call_gpt_api(prompt)

    if response && response["choices"]&.first&.dig("message", "content")
      content = response["choices"].first["message"]["content"]
      Rails.logger.info("ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€Œ#{section_name}ã€ã®æœ¬æ–‡ç”Ÿæˆã«æˆåŠŸã—ã¾ã—ãŸã€‚æ–‡å­—æ•°: #{content.length}") 
      return content
    else
      Rails.logger.error("ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€Œ#{section_name}ã€ã®æœ¬æ–‡ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
      error_text = "ï¼ˆâ€»#{section_name}ã®æœ¬æ–‡ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚APIã‚¨ãƒ©ãƒ¼ã¾ãŸã¯æœ¬æ–‡ãŒç©ºã§ã™ï¼‰"
      if heading_level.empty?
        return error_text + "\n"
      else
        # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®ä»£æ›¿ãƒ†ã‚­ã‚¹ãƒˆã«ã‚‚è¦‹å‡ºã—ã‚’ä»˜ã‘ã‚‹ï¼ˆH3ãªã©ï¼‰
        return "#{heading_level} #{section_name}\n#{error_text}\n" 
      end
    end
  end

  # ==========================================
  # APIé€šä¿¡ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
  # ==========================================
  def self.call_gpt_api(prompt, response_format: nil)
    uri = URI(GPT_API_URL)
    
    # HTTPãƒ˜ãƒƒãƒ€ãƒ¼ã«APIã‚­ãƒ¼ã‚’è¨­å®š
    req = Net::HTTP::Post.new(uri, "Content-Type" => "application/json", "Authorization" => "Bearer #{GPT_API_KEY}")

    payload = {
      model: MODEL_NAME, # å‡¦ç†é€Ÿåº¦ã¨ã‚³ã‚¹ãƒˆã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„ãƒ¢ãƒ‡ãƒ«ã«è¨­å®š
      messages: [
        { role: "system", content: "ã‚ãªãŸã¯ãƒ—ãƒ­ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚ã¾ãŸã€ã€OKé…é€ã€ã¨è¨€ã†è»½è²¨ç‰©é…é€ã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã—ã¦ãŠã‚Šã€ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã®ç›®çš„ã¯è»½è²¨ç‰©ã‚µãƒ¼ãƒ“ã‚¹ã«ç™ºæ³¨ã‚„æ¥­å‹™ææºã‚’çµã³ãŸã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰å•ã„åˆã‚ã›ã‚’å¾—ã‚‹ã“ã¨ã‚’ç›®çš„ã«ã—ã¦ã„ã¾ã™ã€‚ç”Ÿæˆã™ã‚‹æ–‡ç« ã¯ã€Markdownå½¢å¼ã§ã€èª­ã¿ã‚„ã™ã„æ®µè½ã€å¤ªå­—ã€ãƒªã‚¹ãƒˆã‚’ç©æ¥µçš„ã«ä½¿ç”¨ã—ã€Webã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¨ã—ã¦æœ€é©åŒ–ã—ã¦ãã ã•ã„ã€‚ç‰¹ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡ç¤ºã—ãŸæ–‡å­—æ•°åˆ¶é™ã¨**å®£ä¼/CTAã®ç¦æ­¢**ã®æŒ‡ç¤ºã‚’å³æ ¼ã«å®ˆã‚Šã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è³ªã‚’ä¿ã¡ãªãŒã‚‰ã‚‚æŒ‡å®šã•ã‚ŒãŸåˆ¶ç´„ã‚’ç ´ã‚‰ãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚" },
        { role: "user", content: prompt }
      ],
      # temperatureã‚’å°‘ã—ä¸‹ã’ã€ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–æ€§ã‚’æŠ‘ãˆã€æŒ‡ç¤ºã«å¿ å®Ÿã«ãªã‚‹ã‚ˆã†ã«ã—ã¾ã™
      temperature: 0.5 
    }
    
    # JSONå‡ºåŠ›ã‚’å¼·åˆ¶ã™ã‚‹å ´åˆã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
    payload[:response_format] = response_format if response_format.present?

    req.body = payload.to_json

    begin
      # ğŸš¨ ä¿®æ­£ç®‡æ‰€: open_timeout: 60 ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚ æ¥ç¶šç¢ºç«‹ã‚’60ç§’å¾…ã¤
      res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true, read_timeout: 60, open_timeout: 60) do |http| 
        http.request(req)
      end

      if res.is_a?(Net::HTTPSuccess)
        JSON.parse(res.body)
      else
        # ğŸš¨ APIã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®è©³ç´°ãƒ­ã‚°å‡ºåŠ› ğŸš¨
        Rails.logger.error("GPT API error (Status: #{res.code}): #{res.body}")
        nil
      end
    rescue Timeout::Error => e
      Rails.logger.error("GPT API å‘¼ã³å‡ºã—ä¸­ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼: #{e.message} (60ç§’ä»¥å†…ã«å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ)")
      nil
    rescue OpenSSL::SSL::SSLError => e
      Rails.logger.error("GPT API å‘¼ã³å‡ºã—ä¸­ã®SSLã‚¨ãƒ©ãƒ¼: #{e.message}")
      nil
    rescue => e
      # ãã®ä»–ã®é€šä¿¡ãƒ»ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒ
      Rails.logger.error("GPT API å‘¼ã³å‡ºã—ä¸­ã®è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼: #{e.class} - #{e.message}")
      nil
    end
  end
end